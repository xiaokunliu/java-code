##### 数组
1. 基本操作：插入、查找、删除
2. 操作数据是在数组长度已经知道的情况下进行操作，假设为N.
3. 数组操作的基本算法
    * 插入算法：记录元素插入到数组的索引值，每次向数组插入一个元素索引值将自增1，此时插入数组的只需通过arr[index+1] =  element ，直接赋值即可，即1次移动的步长数，即O(1)
	    * 不可重复性：最坏的情况下产生的比较次数为N-1，最好的情况下是1，平均比较是N/2,即O(N);如果不比较则O(1)
	    * 可重复性：在记录有索引的情况下，直接向右移动1次，即可插入数据,即O(1)

    * 查找算法：给定目标key值
	    * 不可重复的数组（相当于查找目标数据中的一个）：遍历数组，最坏为遍历数组的所有，刚好在索引值是N-1找到，比较次数为N-1，
最好的为索引值为0的情况下找到，比较次数为1，平均为 N/2，即O(N)
	    * 可重复的数组（相当于查找目标数据中的所有）：当数组是无序的情况下,遍历数组并且一定是遍历所有,比较次数是N，
因此算法复杂度为O(N)；当数组是有序的情况下，假设最后一个目标数组元素的下标是index,比较次数未index，即0<=index<=N-1，
此时的时间复杂度是O(1)<x<O(N)

    * 删除算法：给定目标，查找算法 + 补洞算法（将删除后的数据的位置进行填充，不允许存在空元素，这会对查找操作增加复杂性）
	    * 不可重复性：查找算法产生的平均比较次数为N/2，补洞算法产生移动的平均次数为N/2
	    * 可重复性：无序可重复性查找产生的平均比较次数为N,假设有m个元素是目标数组，数组下标分别为x1，x2，x3，…..,xm，（且x1<x2<x3...<xm）；第一次补洞产生的步数为N-1-x1，第二次补洞产生的步数为N-2-x2,（原因是第一次补洞后数组元素减少一个），
         依次类推，第m次补洞便是(N-m-xm),总补洞的步数是Sn，即Sn满足以下条件：
         Sn  = （N-1-x1）+ （N-2-x2）+（N-3-x3）+…+（N-m-xm）=mN - （x1+x2+..+xm）-（1+2+..+m）
         当Sn为最优，即最小值，此时满足的条件是x1=N-1,x2=N-2,..xm=N-m,即Sn=0
         当Sn为最坏，即最大值，此时是在m的个数是一定的情况下，即仅考虑数组的小标时，满足的条件是x1=0，x2=1，…，xm=m-1,
         即Sn=-m^2+(N-1)m+1=-(m-(N-1)/2)^2+(N-1)^2/4+1,根据二次函数的单调性可知其最大值为（N-1）^2/4+1，(N-1)^2/4+1 > N/2恒成立，
         因此，其补洞步数平均值总是大于N/2,注意这里的Sn是关于N的一次函数，关于m的二次函数
	    * 可重复性：有序数组，查找最优的步数是便是查找最小值，假设有m个，即查找的步数是m+1,如果查找的是最大值，则查找的步数是N，
	    平均数是（N+m+1)/2 > N，其补洞最优就是补最大值，即0步数；最坏就是补最小值，即根据上面的无序数组计算可知为（N-1）^2/4+1 ，其平均数是（N-1）^2/4 + 1 > N/2恒成立.

4. 数组排序，适用于更新操作不频繁但查询频繁的数据存储结构
    * 可以通过更高效的查询算法提高对数组元素的查询，如二分查找
    * 插入操作需要对靠后的数据进行移动以腾出空间，因此插入速度慢
   
5. 大O表示法
    在不考虑算法空间（一般是指内存空间），可以描述算法的速度是如何与数据项的个数相联系的比较

6. 总结
算法	     | 大O表示时间
-------- | ---
线性查找  |  O(N)
二分查找  | 	O(logN)
无序数组的插入    |  O(1)
有序数组的插入    |  O(N)
无序数组的删除    |  O(N)
有序数组的删除    |  O(N)