[TOC]
#### Java项目实战笔记
##### 1.面向对象编程
##### 1）模型
* 对象模型：定义对「谁」做，描述系统的静态结构，包括类和对象，它们的属性和操作，以及它们之间的关系
* 动态模型：定义「何时」做，着重于系统的控制逻辑，考察在任何时候对象以及关系的改变，描述这些涉及时序和改变的状态
* 功能模型：定义「做什么」，着重于系统内部数据的传送和处理，即通过计算，只要知道输入数据就能得到输出数据而不需要考虑参加计算的数据按照什么时序执行

##### 2）面向对象分析（OOA）
* 论域分析：是软件开发的基本组成部分，目的是使开放人员了解问题空间的组成，建立大致的系统真实实现环境
* 应用分析：是依据在论域分析时建立起来的问题论域模型，并把问题论域模型用于当前特定的应用之中
* 概念：是软件开发过程中的问题定义阶段，主要是描述系统功能和问题空间的基本特征的综合文档，主要考虑『做什么』
* **注意：模型识别的要求可以针对一个应用，也可以针对多个应用，通常我们着重考虑两个方面，即应用视图和类视图，在类视图中，必须详细表示每个类的规格说明和操作，并表示出类之间的相互作用**

##### 3）面向对象设计
* 概念：面向对象设计是面向计算机的实地开发活动，考虑『怎么做』的问题
* 高层设计阶段：开放系统的结构，构造待开放软件的总体模型
* 低层设计阶段：集中于类的详细设计阶段
* **注意：在高层设计过程中，应当使子系统高层部件之间的通信量达到最少，把子系统中相互之间存在高度交互的类进行逻辑分组，而在低层涉及过程中，类的设计需要采用信息隐蔽、高内聚低耦合等设计原则**
	
##### 4）类与对象
* 类与对象的定义
	1. 类是用于创建对象的模板，包含被创建的对象属性和行为方法的定义
	2. 对象就是符合某种类定义所产生出来的实例
* 类的成员
	1. 属性：形容对象的一些特性
	2. 方法：对象的行为或者是使用对象的操作动作
	3. **注意：对于对象而言，属性是属于对象的静态一面（此静态非彼静态，即与类的静态是两回事），用来形容对象的一些特性；而方法属于对象动态的一面，用来操作对象**
	
##### 5）面向对象的特性
```
• 继承：扩展原有基类（父类）的功能，或者是加强or改进父类所没有定义的属性和方法
• 多态：指在父类中定义的属性和方法被子类继承之后，可具有不同的数据类型or表现出不同的行为，即同一个属性or方法在父类和其子类中具有不同的意义
• 封装：其一是保护类中的数据，不被错误地使用or破坏；其二是隐藏类中无需被知道的细节问题
```
#### 2.Java新特性(JDK1.5之后)
##### 1）简单新特性
* 静态导入
	1. 所谓导入，它并不占用系统内存的任何资源，而只是在编写代码时不需要写前缀中的包名，即import static java.lang.System.*
	2. 针对一个给定的包，不可能用一行语句静态地导入包中所有类的所有方法和类变量，即不能这样写：import static java.lang.*
	3. 如果本地方法和静态导入的方法有着相同的名字，则本地方法被调用，若静态导入两个类中同名的类变量或者类方法，则必须通过对象or类名使用类变量、类方法；
	
* 可变参数函数
	1. 格式：函数修饰符  返回类型  函数名（参数类型…   参数名）{}
	2. 可变形参只能位于参数列表的最后，编译器在具体处理可变参数函数时，会为该参数创建一个数组，以数组的形式访问可变参数
	3. 增强版for循环
	4. 格式：for(type 变量名:集合变量名){}
	
* 自动拆装箱
	1. int，integer，在-128~127之间，返回的对象（自动装箱）会引用同一个对象，否则将各自创建相应的装箱对象
	2. 自动装箱，由int的数据转换integer的方式，new integer()，Integer.valueOf()，以及自动装箱操作Integer data = 12；
	3. 自动拆箱，int sum = data + 20，将上述的data（integer）转换为int类型的数据，即所谓的自动拆箱功能
	
##### 2）枚举
	•	作用：在应用程序中设置变量的取值只能为若干个固定值的一个，并且能够在编译器进行编译时进行检查，防止取值不当而使编译器报错
	•	枚举类
		◦	对于构造方法，必须放在枚举常量之后
		◦	构造方法必须是使用private的修饰符修饰
		◦	枚举类自定义的构造函数不能覆盖默认执行的构造函数，只会在其后运行
		◦	枚举类初始化对象时，会根据枚举常量括号里的参数决定，当无括号或者空括号时，则会调用无参数构造器，当传递给常量带有括号的参数则会调用相应地带参数构造器
		◦	枚举类是属于一个多例模式，每一个常量对象都是单例模型，不同常量表示的对象意义不同，即多例模式
		◦	枚举类定义抽象方法，必须定义在所有常量之后，并且每个常量都必须实现该抽象方法

##### 3）反射
	•	反射：程序自己能够检查自身的信息，反射使Java语言具有『动态性』，即程序首先会检查某个类中的方法、属性等信息，然后再动态地调用或动态创建该类或该类的对象
	•	Class类：Class实例代表内存中的一份字节码，字节码就是Java虚拟机加载某个类的对象时，首先需要把硬盘该类的二进制源码编译成class文件的二进制代码（字节码），然后把class文件的字节码加载到内存中，之后再创建该类的对象
	•	获取Class对象方法
		◦	实例对象.getClass（）方法
		◦	Class类的静态方法，即Class.forName（）来获取与字符串对应的Class对象
		◦	通过类名.class
		◦	Class方法
	•	isPrimitive()-->判断字节码的类是否基本类型（boolean、byte、char、short、int、long、float、double和void）
	•	int类型与Integer类的字节码不是属于同一个字节码对象，但是Integer.TYPE是int基本类型的字节码对象
	•	判断是否为数组的字节码，可以通过Class类的isArray()方法来实现
	•	反射的基本应用
		◦	Class：表示一个类的字节码类，Field：表示属性的类，Method：表示方法的类，Constrctor：表示类的构造方法的类
		◦	成员方法的反射，如果传递的第一参数是null表明是调用静态方法，否则是调用类的实例方法
		◦	相同维数和元素类型的字节码相同，即具有相同的Class实例对象
		◦	基本类型的一维数组只能转换为Object对象，不能转换为一维的Object[]数组对象，非基本类型的一维数组既可以当Object对象使用，也可作为Object的一维数组使用

##### 4）注解
	•	JDK内置的注解
		◦	@Override：只作用于方法，主要用在子类覆盖父类的方法名称时，检测方法名称以及对应的方法形参是否与父类一致，不仅可以放在方法的上边，也可以放在方法的前面，即@Override pulic ….
		◦	@Deprecated：当一个类或者类成员使用@Deprecated修饰时，编译器将不鼓励使用这个被标注的程序元素，而且这种修饰具有一定的『延续性』，即在代码中通过通过继承或者覆盖的方式使用过时的类或类成员，虽然继承或覆盖后的类型或类成员并不是被声明为@Deprecated的，但编译器仍然要报警，@Deprecated标注不仅可以用在方法的前边，还能用在餐宿或类的前边
		◦	@SuppressWarnings：被用作标注类、属性、方法等成员，主要用于屏蔽警告，并且可以带有参数，deprecation：已经过时警告，unused：没有使用的警告，unchecked：类型不安全的警告，@SuppressWarnings（{『deprecation』，『unused』，『unchecked』}）
	
##### 5）泛型
	•	泛型的本质就是实现参数化类型，也就是操作的一个数据类型被指定为一个参数，即防止编译阶段通过传递Object类型的『任意化』，也就是在进行强制类型转换的时候，编译器是不会出现提示错误的，但是在运行时却会出现异常
	•	作用：防止运行时出现强制类型转换错误，即在保证程序在编译阶段就能够识别出添加到集合容器中的不合法的类型
	•	泛型的特性：List<String>称为参数化类型，String为类型参数的实例或者实际类型参数，<>称为typeof
		◦	参数类型与原始类型的兼容，如：Vector<String> v = new Vector();（参数化类型引用一个原始类型）,Vector v = new Vector<String>();（原始类型引用一个参数化类型），编译器不会报错，但会警告
		◦	参数化类型无继承性，如Vector<String> v = new Vector();Vector<Object> va = v;（报编译错）
		◦	泛型的去类型化：也就是说泛型中的类型只是提供给编译器使用来防止程序编码出现的类型错误，而实际在编译形成class文件的时候则不存在泛型的类型
		◦	反射绕过泛型的类型限制：反射是根据字节码来创建一个类的实例，而编译生成的字节码是不存在参数化类型，即泛型，因此在使用反射通过反射的method.invoke()方法便可以随意传递参数到集合容器中
	•	泛型的通配符
		◦	『？』标识可以实现接受任何类型参数的方法，即在具体调用该方法时，传入的对象可以是任意类型，但是在具体接受什么类型只有在具体调用方法时才能确定，因此在方法定义指定的泛型参数化类型时，如果传递的参数与泛型定义的参数不一致，则会编译出现错误
		◦	<? Extends U>:表示容器or方法接受的参数对象可以是U以及U对应的子类对象参数
		◦	<? super U>:表示容器or方法接受的参数对象可以是U以及U对应的任何父类对象参数
	•	泛型使用规则：如果要向容器中添加元素则使用<? Super T>,如果要从容器中获取元素则用<? Extends T>,若既要获取又要添加则不使用通配符
	
##### 6）类加载器
* 程序在运行过程中，类加载器将Java编译器编译生成的class文件按照需求和一定规则加载到JVM内存中，并组织称为一个完整的Java应用程序，这是类加载器自动完成的工作
	1. 作用：加载字节码class文件的工具，JVM第一件事就是将类的字节码加载到JVM内存中（类加载器存在于JVM中），也可以理解为类加载器加载某个类字节码的过程实际上就是创建Class对象的一个实例
	2. 运行原理：首先，JVM会将类的字节码存储到内存中，同时会将索引信息存储到一个HashTable中，注意索引的关键字就是被加载类的完整路径名称，当要运行某一个类时，JVM就通过使用类名作为关键字在HashTable中查找相应的信息，如果类的字节码存在，则直接运行，如果不存在，则调用类的加载器负责将编译好的class文件加载到内存中
* 类加载器的委派模型
	1. 第一个类加载器：BootstrpLoader，即引导类加载器，负责加载其他的类加载器，而BootstrpLoader是由JVM内置的C++编写的一个类加载器，由操作系统的本地代码实现，主要负责加载%JAVA_HOME%/jre/lib的目录下的jar文件
	2. 第二个类加载：ExtClassLoader，由java编写的类加载器，主要加载%JAVA_HOME%/jre/lib/ext目录下的jar或者是通过java.ext.dir这个系统属性指定路径下的代码
	3. 第三个类加载器：AppClassLoader，主要加载应用程序下的jar，即CLASSPATH这个系统属性指定路径在的jar
	4. 委派机制：首先，在定义一个类加载器时，必须为其指定一个父类加载器对象，如一个应用程序的加载器要加载一个类时，首先会委托其父类加载器ExtClassLoader，而扩展的类加载器则会委托引导类加载BootstrpLoader去加载类，如果父类加载器在自己的类库中没有找到该类，则交由子类去加载其所在类库路径，如果最终的子类也不能类将会报错ClassNotFoundException
* 类加载器主要方法
	1. loadClass方法：加载指定名称（包括包名）的二进制类型
	2. findClass方法：加载指定名称类，该方法一般被loadClass方法调用去加载指定名称类，同时还实现加载委派规则
	3. defineClass方法：生成类的实例对象，即主要通过解释字节码把它转换为运行时的数据结构，这个包含数据的原始字节数组可能来自于文件系统或者是网络
* 自定义的类加载器
	1. 首先，继承ClassLoader类，然后覆盖该类的findClass方法
	2. 其次，在findClass方法中自定义类加载器处理字节码的规则，最后通过defineClass方法将得到的类的字节数组生成class文件
	
##### 7）动态代理
* 动态代理的基础类Proxy的类方法
	1. getProxyClass：用于创建动态代理类的字节码，其完整定义为：public static Class<?> getProxyClass(ClassLoader loader,Class<?>[] interface) throws IllegalArgumentException,loader为动态代理类的类加载器，interface是指定动态代理类所要实现的接口
	2. newProxyInstance()：用于创建动态代理类的实例对象，其完整定义为：public static Object newProxyInstance(ClassLoader loader,Class<?>[] interface,InvocationHandler handler) throws IllegalArgumentException,loader为动态代理类的类加载器，interface是指定动态代理类所要实现的接口,handler指定与动态代理类关联的InvocationHandler对象，直接可以创建实例对象，相当于getProxyClass之后，再获取构造器，通过构造函数创建动态代理的实例对象
	3. 作用：为保证程序设计的类具有单一性原则，即类中的每一个功能尽可能单一，而当一个完整的业务需要各个类的功能组合而成，为提高其可维护性和扩展性，可以使用代理将各个类的功能进行组合增强，有时候一个类的功能增强还可以使用包装的设计来增强类的功能，具体根据业务需要而定






