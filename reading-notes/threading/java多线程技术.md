[TOC]
#### Java多线程核心技术
#####  1. volatile关键字
```
作用：
1)使变量在多个线程间可见
2)强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值
不足：线程安全主要是体现在原子性和可见性，volatile只满足可见性，不具备原子性

使用场景：
用于多线程总感知实例变量被更改，并且可以获得最新的值引用，也就是多线程读取共享变量时可以获得最新的值引用

volatile与synchronized比较
1）volatile是线程同步的轻量级实现，在性能上比synchronized要好，并且只能修饰变量，而
synchronized可以修饰方法以及代码块，随着jdk新版本的发布，synchronized在执行效率上得到很大的提升
2）多线程访问volatile不会阻塞，而synchronized会产生阻塞
3）volatile能够保证数据的可见性，但无法保证线程的原子性，它会去读取公共内存的数据，而synchronized既保证数据可见性也间接保证线程原子性，因为它将公共的和线程私有读取的内存做同步
4）volatile是解决变量在多线程之间的可见性，而synchronized是解决多线程之间访问的资源同步性
5）synchronized可以使得多线程访问同一个资源具有同步性，而且它还具有将线程工作内存中的私
有变量与公共内存中的变量同步

AtmoicInteger原子类操作
线程无法中断或者检查原子操作中的变量，即AtmoicInteger只能保证在处理数据（获取，计算，赋值）过程是原子性的，整体逻辑有多个原子性操作，如果整体逻辑需要原子性，那么变需要对多个原子性操作加锁：
每个原子性操作相互独立
{
	原子操作1
	原子操作2
	....
}
整体逻辑是体现原子性操作
{
	synchronized(resources){
		原子操作1
		原子操作2
		....
	}
}

同步synchronized不仅可以解决一个线程看到对象处于不一致的状态,还可以保证进入同步方法或
同步代码块中的每个线程,都看到由同一个锁保护之前所有的修改效果,
在这里,也就是isContinue可以所有线程可见,当该值产生变化时,其他线程也可以看到

```

##### 2.线程等待/通知机制
```
wait():可以使调用该方法的线程释放共享资源的锁，然后从运行状态中退出，进入等待队列，直到被再次唤醒
notify():可以随机唤醒等待队列中等待同一个共享资源的『线程』，并且使得该线程退出等待状态，进入可运行状态，也就是notify()仅仅通知一个
notifyAll():可以使得所有正在等待线程队列中等待同一个共享资源的『全部』，所有的线程从等待状态退出，进入可运行状态，此时优先级最高的线程先执行，但也可能是随机执行（取决于JVM的实现）
执行wait方法释放锁资源，执行notify方法步释放锁资源
```
* 线程状态图
	
```sequence
新的线程[new Thread()]->运行: start()
运行->>暂停:suspend()/sleep()/wait()
暂停->>运行:resume()
新的线程[new Thread()]-->销毁:stop()
运行-->销毁:run()正常结束/stop()
暂停-->销毁:stop()
```

* 线程可运行状态（Runnable）
	* 调用sleep()方法后经过的时间超过了指定的休眠时间
	* 线程调用的阻塞IO已经返回，阻塞方法执行完毕
	* 线程成功获得试图同步的监视器
	* 线程正在等待某个通知，其他线程发出了通知
	* 处于挂起状态的线程调用了resume方法
* 线程的阻塞状态（Blocked）
	* 线程调用sleep方法，主动放弃占用的处理器资源
	* 线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞
	* 线程试图获取同步监视器，但是该同步监视器正被其他线程所持有
	* 线程等待某个通知，也就是线程调用了wait()方法
	* 程序调用了suspend方法将该线程挂起，此方法容易产生死锁

##### 3.线程通信
* wait/notify方法
* join方法
	* 作用：等待线程对象被销毁，即使得所属的线程对象x正常执行run()方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码
	* join方法具有使线程排队运行的作用，有点类似同步的效果
	* 与synchronized区别：join在内部使用wait方法进行等待，synchronized使用的是『对象监视器』原理作为同步性
	* join(long)与sleep(long)：join内部使用wait(long)，所以join具有释放锁的功能，而sleep不具备释放锁功能
* ThreadLocal
	* 作用：实现每一个线程共享自己的私有数据，也就是说保证每一个线程不论在何种情况下都能够获取并操作该线程内的私有数据
* Lock && Condition
	* lock.getHoldCount():查询当前线程保持此锁定的个数，也就是调用lock方法的次数
	* lock.getQueueLength():返回正等待获取此锁定的线程估计数
	* lock.getWaitQueueLength(Condition condition):返回此等待与锁定的相关给定条件Condition的线程估计数
	* lock.hasQueueThread(threadInstance):查询指定的线程是否正在等待获取此锁定
	* lock.hasQueueThreads():是否有线程正在等待获取锁定
	* lock.hasWaiters():查询是否有线程正在等待与此锁定有关的condition条件
	* lock.isFair():判断是否为公平锁，ReentrantLock默认是使用非公平锁
	* lock.isLock():查询此锁定是否由任意线程保持
	* lock.lockInterruptibly():如果当前线程未被中断则获取锁定，若已经中断则会抛出异常，需要注意的是lock方法是当线程被中断的时候仍然正常执行，lockInterruptibly则是当已经中断那么就抛出异常
	* lock.tryLock():尝试获取锁，在还没锁定资源的情况下获取资源锁，如果资源锁已经被其他线程获取，则将返回false
