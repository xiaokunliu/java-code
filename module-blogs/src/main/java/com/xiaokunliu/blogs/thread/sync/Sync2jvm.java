package com.xiaokunliu.blogs.thread.sync;

/**
 * date:2020/1/7 10:37
 * author:keithl
 * desc: business desc etc.
 */
public class Sync2jvm {

    // TODO write your logic code

    {
        synchronized (Sync2jvm.class) {

        }
    }

    // 1。锁的工作原理
    // synchronized方法级别

    // 方法级同步是隐式执行的，作为方法调用和返回的一部分(§2.11.8)
    // 同步方法在运行时常量池的method_info结构(§4.6)中由ACC_SYNCHRONIZED标志加以区分，该标志由方法调用指令进行检查
    // 当调用为其设置ACC_SYNCHRONIZED的方法时，执行线程将进入监视器，调用方法本身，并退出监视器，不管方法调用是正常完成还是突然完成。
    // 在执行线程拥有监视器期间，其他线程不能进入监视器。如果在调用同步方法期间抛出异常，
    // 而同步方法不处理该异常，则在从同步方法重新抛出异常之前，方法的监视器将自动退出


    // synchronized代码块级别
    // 指令序列的同步通常用于编码Java编程语言的同步块。Java虚拟机提供monitorenter和monitorexit指令来支持这种语言结构。
    // 同步块的正确实现需要针对Java虚拟机的编译器的合作(§3.14)


    //结构化锁定是这样一种情况:在方法调用期间，给定监控器上的每个出口与该监控器上的前一个入口匹配。由于不能保证提交给Java虚拟机的所有代码都将执行结构化锁定，所以允许Java虚拟机的实现，
    // 但不要求强制执行下面两条保证结构化锁定的规则。假设T是一个线程，M是一个监视器。
    // 1。 监视器的入口数量与出口数量一致
    // 2。 方法调用期间（方法执行中）监视器的出口数量不可能超过刚进入方法调用期间的出口数量（方法执行前，准备执行调用方法）

    // 注意，Java虚拟机在调用同步方法时自动执行的监视器入口和出口被认为是在调用方法的过程中发生的


    // 2。锁存储的位置


    // 3。基于原理的执行流程


    // 4。源码实现

}
