package com.xiaokunliu.commons.db;

import org.apache.commons.dbcp.BasicDataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;

/**
 * date:2019/11/10 18:02
 * author:keithl
 * desc: business desc etc.
 */
public class DBSupport {

    private static BasicDataSource bds = new BasicDataSource();

    static {
        String url = "jdbc:mysql://123.207.54.53:3306/dtrees_shop";
        String driverName = "com.mysql.jdbc.Driver";
        bds.setDriverClassName(driverName);
        bds.setUrl(url);
        bds.setUsername("root");
        bds.setPassword("root123");
        bds.setInitialSize(1);  // 初始连接
        bds.setMaxActive(25);    // 最大连接
        bds.setMaxIdle(15);      // 最大空闲
        bds.setMinIdle(1);      // 最小连接数
        bds.setMaxWait(12000);
        bds.setRemoveAbandoned(true);
        bds.setRemoveAbandonedTimeout(180);
    }

    protected Connection conn;
    private Logger LOG = LoggerFactory.getLogger(DBSupport.class);

    protected Connection getConnection() throws SQLException {
        return bds.getConnection();
    }

    public void beginTransaction() throws SQLException {
        if (conn == null) {
            conn = getConnection();
        }
        conn.setAutoCommit(false);
    }

    public void rollback() throws SQLException {
        if (null != conn) {
            conn.rollback();
        }
    }

    public void endTransaction() throws SQLException {
        if (null != conn) {
            conn.commit();
            conn.setAutoCommit(true);
        }
    }

    /**
     * 使用prepareStatement预编译sql语句
     *
     * @param sql
     * @throws SQLException
     */
    protected PreparedStatement prepareStatement(String sql) throws SQLException {
        if (conn == null) {
            conn = getConnection();
        }

        if (conn == null) {
            throw new SQLException("conn is null!");
        }
        //conn.setAutoCommit(true);
        return conn.prepareStatement(sql);
    }

    /**
     * 使用prepareStatement预编译sql语句
     *
     * @param sql
     * @throws SQLException
     */
    protected PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        if (conn == null) {
            conn = getConnection();
        }

        if (conn == null) {
            throw new SQLException("conn is null!");
        }
        //conn.setAutoCommit(true);
        return conn.prepareStatement(sql, autoGeneratedKeys);
    }

    protected CallableStatement prepareCall(String procedure) throws SQLException {
        conn = getConnection();
        return conn.prepareCall(procedure);
    }

    /**
     * 说明:一个返回受影响的行数的提交方法
     *
     * @param sql
     * @return 返回受影响的数量
     * @throws SQLException
     */
    public int execute(String sql) {
        return execute(sql, new Object[]{});
    }

    public int execute(String sql, Object[] params) {
        PreparedStatement pstmt = null;
        try {
            pstmt = prepareStatement(sql);
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            return pstmt.executeUpdate();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            LOG.info(pstmt + "");
            this.closePstmt(pstmt);
        }
    }

    public int executeAndGeneratedKeys(String sql, Object[] params) {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            pstmt = prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            pstmt.executeUpdate();

            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            throw new RuntimeException(e);
        } finally {
            LOG.info(pstmt + "");
            this.closeAll(rs, pstmt);
        }
        return 0;
    }

    public boolean queryForBoolean(String sql) {
        return queryForBoolean(sql, new Object[]{});
    }

    public boolean queryForBoolean(String sql, Object[] params) {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            pstmt = this.prepareStatement(sql);
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            rs = pstmt.executeQuery();

            if (null == rs) return false;

            if (rs.next()) return rs.getBoolean(1);
            return false;
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            throw new RuntimeException(e);
        } finally {
            LOG.info(pstmt + "");
            this.closeAll(rs, pstmt);
        }
    }

    public Integer count(String sql, Object[] params) {
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            pstmt = this.prepareStatement(sql);
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            rs = pstmt.executeQuery();
            if (null == rs) return -1;

            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (Exception e) {
            LOG.error(e.getMessage(), e);
            throw new RuntimeException(e);
        } finally {
            LOG.info(pstmt + "");
            this.closeAll(rs, pstmt);
        }
    }

    public DoBatch doBatch(String sql, DBSupport op) {
        return new DoBatch(sql, op);
    }

    protected void closePstmt(PreparedStatement pstmt) {
        try {
            if (pstmt != null) {
                pstmt.close();
                pstmt = null;
            }
            this.closeConn();
        } catch (SQLException e) {
            LOG.error("close prepstmt" + e);
        }
    }

    protected void closeRs(ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
                rs = null;
            }
            this.closeConn();
        } catch (SQLException e) {
            LOG.error("close ResultSet" + e);
        }
    }

    private void closeConn() {
        try {
            if (conn != null) {
                conn.close();
                conn = null;
            }
        } catch (SQLException e) {
            LOG.error("close conn" + e);
        }
    }

    protected void closeAll(ResultSet rs, PreparedStatement pstmt) {
        closeRs(rs);
        closePstmt(pstmt);
        closeConn();
    }

    public class DoBatch {

        private DBSupport op;
        private PreparedStatement pstmt;
        private String sql;

        public DoBatch(String sql, DBSupport op) {
            this.op = op;
            this.sql = sql;
            initBatch();
        }

        public DoBatch addBatch(Object[] params) {
            try {
                for (int i = 0; i < params.length; i++) {
                    this.pstmt.setObject(i + 1, params[i]);
                }
                this.pstmt.addBatch();
            } catch (SQLException e) {
                LOG.error(e.getMessage(), e);
                throw new RuntimeException(e);
            }
            return this;
        }

        public int[] execute() {
            try {
                return this.pstmt.executeBatch();
            } catch (Exception ex) {
                LOG.error("dbTrans.doBatch" + ex.getMessage(), ex);
                throw new RuntimeException(ex);
            } finally {
                op.closePstmt(pstmt);
            }
        }

        public void initBatch() {
            try {
                pstmt = op.prepareStatement(sql);
                LOG.info(sql);
            } catch (SQLException e) {
                LOG.error(e.getMessage(), e);
                throw new RuntimeException(e);
            }
        }
    }
}
