#### JVM基本组成
> PC寄存器
* 一块较小的内存空间
* 作用：可以看做是当前线程所执行的字节码的行号指示器
```code 
每一条JVM线程都有自己的PC寄存器，在任意时刻，一条JVM线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法,若该方法不是属于native方法，则PC寄存器会保存JVM正在执行的字节码指令的地址，若是native方法，则pc寄存器的值是undefined，pc寄存器的容量至少能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值
```

> JVM栈
* 存储局部变量与一些尚未算好的结果
* 异常
    * JVM线程请求分配的栈容量超过栈允许的最大容量时，将会抛出一个StackOverflowError异常
    * JVM栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存时将会抛出一个OutOfMemoryError异常

> JVM堆
* 是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域
* 异常
    * 若实际所需的堆超过了自动内存管理系统能提供的最大容量，则Java会抛出一个OutofMemoryError异常

> 方法区
* 存储每一个类的结构信息，包括运行时的常量池、字段和方法数据、构造函数和普通方法的字节码内容以及一些在类、实例、接口初始化时用到的特殊方法
* 方法区时在虚拟机启动的时候创建，虽然是属于堆得逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不识闲垃圾收集与压缩

> 运行时常量池
* 是class文件中每一个类或者接口的常量池表
* 每一个运行时常量池都在Java虚拟机方法中分配，在加载类和接口到虚拟机后，就创建相应的运行时常量池

> 本地方法栈
* 支持native方法（Java以外的其他语言编写的方法，如C语言）

> 栈帧（存储数据、部分过程结果的数据结构、动态链接、方法返回值以及异常分派）
```comment 
1. 当前栈帧：在某个线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的
2. 当前方法：栈帧对应的方法
3. 当前类：定义栈帧当前方法的类
```

* 局部变量表（栈帧）
    * 一个局部变量表可以保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress的数据，一般是用两个连续局部变量可以保存一个类型为long或者是double的数据
    * 局部变量表适应索引来访问，首个索引值为0，局部变量的索引值是个整数，其取值范围0<=len<table_size
    * 当调用类方法时，它的参数将会依次传递到局部变量表中从0开始的连续位置上
    * 当调用实例方法时，第0个局部变量一定是用来存储改实例方法所在对象的引用this

* 操作数栈（栈帧）
    * 操作数栈最大的深度由编译期决定
    * 存储局部变量表或者是对象实例的字段中复制常量或者是变量值到操作数栈中
    * 调用方法时，操作数栈也用来准备调用方法的参数以及接受方法返回结果
    * 操作数栈的每个位置可以保存一个JVM中定义的任意数据类型的值，包括long和double类型
    
* 动态链接（栈帧）
    * 每隔栈帧内部都包括一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接
    * 在class文件中，一个方法若要调用其他方法，或者是访问成员变量，则需要通过符号引用来标示，动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的直接引用
    * 类加载的过程中将要解析尚未被加载的符号引用，并且将对变量的访问转化为变量在程序运行时，位于存储结构中的正确偏移量

* 方法调用正常完成（栈帧）
    * 在方法的执行过程中，没有抛出任何异常，包括直接从Java虚拟机中抛出的异常以及在执行时通过throw语句显示抛出的异常
    
* 方法调用异常完成（栈帧）
    * 在方法执行的过程中，某些指令导致了Java虚拟机抛出异常，并且在虚拟机抛出的异常方法中没有办法处理，或者在执行过程中遇到athrow字节码指令并显示地抛出异常，并且在该方法内部没有捕获异常。

